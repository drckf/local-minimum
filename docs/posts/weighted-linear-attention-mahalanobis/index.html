<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Charles Fisher">
<meta name="dcterms.date" content="2025-05-20">

<title>Weighted Linear Attention with Mahalanobis Loss – Local Minimum</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Local Minimum</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../license.html"> 
<span class="menu-text">License</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/drckf"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Weighted Linear Attention with Mahalanobis Loss</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">research</div>
                <div class="quarto-category">machine-learning</div>
                <div class="quarto-category">ecology</div>
                <div class="quarto-category">attention</div>
                <div class="quarto-category">lotka-volterra</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Charles Fisher </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 20, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">TLDR</h2>
<p>Weighted linear attention modules are key-value associative memories with potential uses in neural sequence models used for tasks such as language modeling. In previous posts, I showed that weighted linear attention can be interpreted as an evolving ecological system in which tokens are species and their weights are species abundances. The weights evolve under Lotka-Volterra dynamics when optimized via exponentiated gradient descent to minimize the squared recall error. The squared error, however, doesn’t take into account the variance of, or correlations between, different elements of the value vectors. Here, I extend the approach by deriving similar results that minimize the Mahalanobis distance in both batch and online learning settings.</p>
</section>
<section id="review-of-previous-results" class="level2">
<h2 class="anchored" data-anchor-id="review-of-previous-results">Review of Previous Results</h2>
<p>In a previous post <a href="../../posts/weighted-linear-attention-is-lotka-volterra/index.html">Weighted Linear Attention is Lotka-Volterra Dynamics</a>, I showed that weighted linear attention modules can be interpreted as ecological systems where tokens are species and their weights are species abundances. The weights evolve under Lotka-Volterra dynamics when optimized via exponentiated gradient descent to minimize the squared recall error. To briefly review those results, I focus on a particular form of weighted linear attention module determined by an associative memory matrix, <span class="math display">\[
J = \sum_{l} w_{l} \, \vec{v}_{l} \, \vec{k}_{l}^T \,,
\]</span> where <span class="math inline">\(l\)</span> denotes the token position, <span class="math inline">\(\vec{v}_l = W_{V} \vec{x}_l \in \mathbb{R}^{d_v}\)</span> is a value vector, <span class="math inline">\(\vec{k}_l = W_{K} \vec{x}_l \in \mathbb{R}^{d_k}\)</span> is a key vector, <span class="math inline">\(\vec{x}_l \in \mathbb{R}^{n}\)</span> is a token embedding, and <span class="math inline">\(w_l \geq 0\)</span> is the weight of token <span class="math inline">\(l\)</span> in memory. Recall from the memory is simply matrix multiplication, <span class="math display">\[
\tilde{v}_l = J \, \vec{q}_l
\]</span> where <span class="math inline">\(\vec{q}_l = W_Q \vec{x}_l \in \mathbb{R}^{d_k}\)</span> is a query vector. The mean squared recall error for a batch of tokens <span class="math inline">\(\{ \vec{x}_l \}_{l=1}^L\)</span> is (up to a factor of <span class="math inline">\(1/2\)</span>), <span id="eq-squared-loss"><span class="math display">\[
C(\vec{w}) = \frac{1}{2 L} \sum_{l=1}^L || \vec{v}_l - J \, \vec{q}_l ||^2 \, .
\qquad(1)\]</span></span> To learn the weights, the cost function can be minimized using a simple variant of exponentiated gradient descent to satisfy the non-negativity constraint. In the continuous-time limit, this update rule leads to the following differential equation <span class="math display">\[
\frac{d \, w_l}{d \, t} = - w_l \frac{\partial C}{\partial w_l}
\]</span> that describes the dynamics of the weights under the exponentiated gradient descent. After a bit of algebra, it’s possible to show that the following generalized Lotka-Volterra equation describes the dynamics of the weights, <span id="eq-lotka-volterra"><span class="math display">\[
\frac{d \, w_l}{d \, t} =  w_l \Big( s_l - \sum_{l'} A_{l, l'} \, w_{l'} \Big) \,,
\qquad(2)\]</span></span> where <span class="math display">\[
\begin{align}
s_l &amp;= \vec{k}_l^T \, \Sigma_{qv} \, \vec{v}_l \,,
\\
A_{l,l'} &amp;= \vec{v}_l^T \, \vec{v}_{l'} \, \vec{k}_{l'}^T \, \Sigma_{qq} \, \vec{k}_{l}
\, ,
\end{align}
\]</span> <span class="math inline">\(s_l\)</span> is the intrinsic growth rate of token <span class="math inline">\(l\)</span>, <span class="math inline">\(A_{l,l'}\)</span> is the interaction coefficient for tokens <span class="math inline">\(l\)</span> and <span class="math inline">\(l'\)</span>, <span class="math inline">\(\Sigma_{qv}\)</span> is the uncentered query-value correlation matrix, and <span class="math inline">\(\Sigma_{qq}\)</span> is the uncentered query-query correlation matrix.</p>
</section>
<section id="mahalanobis-loss" class="level2">
<h2 class="anchored" data-anchor-id="mahalanobis-loss">Mahalanobis Loss</h2>
<p>The squared Mahalanobis loss defined by <span id="eq-mahalanobis-loss"><span class="math display">\[
C(\vec{w}) = \frac{1}{2 L} \sum_{l=1}^L (\vec{v}_l - J \, \vec{q}_l)^T \Sigma_{vv}^{-1} (\vec{v}_l - J \, \vec{q}_l)  \, .
\qquad(3)\]</span></span> is closely related to <a href="#eq-squared-loss" class="quarto-xref">Equation&nbsp;1</a> except that distances take into account the geometry of the value vectors through their correlation matrix <span class="math inline">\(\Sigma_{vv}\)</span>. After following a calculation similar to the previous posts on the mapping between weighted linear attention and Lotka-Volterra systems, one arrives at a differential equation for the training dynamics <span class="math display">\[
\frac{d \, w_l}{dt} = w_l \left( s_l - \sum_{l'} A_{l,l'}\, w_{l'} \right) \,,
\]</span> where <span class="math display">\[
\begin{align}
s_l &amp;= \vec{k}_l^T \left( \frac{1}{L}\sum_{i=1}^L \vec{q}_i\, (\vec{v}_i^T \Sigma_{vv}^{-1}) \right) \vec{v}_l \,, \\[1mm]
A_{l,l'} &amp;= \vec{v}_l^T \, \Sigma_{vv}^{-1} \, \vec{v}_{l'} \, \vec{k}_{l'}^T \left( \frac{1}{L}\sum_{i=1}^L \vec{q}_i \vec{q}_i^T \right) \vec{k}_l \,,
\end{align}
\]</span> are the intrinsic growth rates and the interaction coefficients, respectively. In terms of the correlation matrices, the ecological parameters are <span class="math display">\[
\begin{align}
s_l &amp;= \vec{k}_l^T \Sigma_{qv} \, \Sigma_{vv}^{-1} \, \vec{v}_l \,, \\[1mm]
A_{l,l'} &amp;= \vec{v}_l^T \, \Sigma_{vv}^{-1} \, \vec{v}_{l'} \, \vec{k}_{l'}^T  \, \Sigma_{qq} \, \vec{k}_l \,.
\end{align}
\]</span> Notice that if we define <span class="math display">\[
\vec{\nu}_l = \Sigma_{vv}^{-1/2} \vec{v}_l \,,
\]</span> corresponding to a whitened version of the value vector, then the intrinsic growth rates and interaction coefficients can be written as <span class="math display">\[
\begin{align}
s_l &amp;= \vec{k}_l^T \, \Sigma_{q \nu} \, \vec{\nu}_l \,, \\[1mm]
A_{l,l'} &amp;= \vec{\nu}_l^T \, \vec{\nu}_{l'} \, \vec{k}_{l'}^T \Sigma_{qq} \vec{k}_l \,.
\end{align}
\]</span> which is identical to the previous result with the standard squared loss except it uses the whitened value vectors.</p>
</section>
<section id="online-learning" class="level2">
<h2 class="anchored" data-anchor-id="online-learning">Online Learning</h2>
<p>Following the same logic as in the previous post <a href="../../posts/weighted-linear-attention-as-species-invasion/index.html">Weighted Linear Attention as Species Invasion</a>, I will use a simple approximation for the online learning scenario by assuming that the arrival of a new token <span class="math inline">\(l\)</span> updates the memory matrix as <span id="eq-single-species-lv-memory-update"><span class="math display">\[
J_l = \omega_f \, J_{l-1} + \omega_i \, \vec{v}_l \, \vec{k}_l^T \,,
\qquad(4)\]</span></span> where <span class="math inline">\(\omega_f \geq 0\)</span> is a forget gate and <span class="math inline">\(\omega_i \geq 0\)</span> is an input gate <span class="citation" data-cites="beck2025xlstm">(<a href="#ref-beck2025xlstm" role="doc-biblioref">Beck et al. 2025</a>)</span>. This assumes that the incoming token <span class="math inline">\(l\)</span> interacts with a fixed memory defined by <span class="math inline">\(J_{l-1}\)</span> and the arrival of the new token does not adjust the weights of any previous tokens. Given that this is a type of greedy update rule, I refer to this as greedy invasion. With this assumption, the Mahalanobis cost function becomes, <span class="math display">\[
\begin{align}
C_l(\omega_i)
&amp;= \frac{1}{2} d_v
- \omega_f \, s_J + \frac{1}{2} \omega_f^2 \, A_{J,J}
\\
&amp;\quad - \omega_i s_l + \frac{1}{2} \omega_i^2 A_{l,l}
+ \omega_i \, \omega_f \, A_{J,l}
\end{align}
\]</span> where <span class="math display">\[
\begin{align}
s_{J} &amp;=  \text{Tr}\Big(\Sigma_{vv}^{-1} J_{l-1} \, \Sigma_{qv} \Big)
\\
s_{l} &amp;= \vec{k}_l^T \, \Sigma_{qv} \, \Sigma_{vv}^{-1} \vec{v}_l
\\
A_{J, J} &amp;= \text{Tr}\Big(\Sigma_{vv}^{-1} \, J_{l-1} \, \Sigma_{qq} \, J_{l-1}^T \Big)
\\
A_{l, l} &amp;= \vec{v}_l^T \, \Sigma_{vv}^{-1} \, \vec{v}_l \, \vec{k}_l^T \, \Sigma_{qq} \, \vec{k}_l
\\
A_{J, l} &amp;= \vec{v}_l^T \, \Sigma_{vv}^{-1} \, J_{l-1} \, \Sigma_{qq} \, \vec{k}_l
\end{align}
\]</span> are online estimates for the intrinsic growth rates and interactions and the correlation matrices are computed from online updates based on the currently observed tokens. In the previous post, I included a superscript on the correlation matrices such as <span class="math inline">\(\Sigma_{qq}^l\)</span> to denote that they were computed from <span class="math inline">\(l\)</span> tokens, but I’ve suppressed that notation here for simplicity. These formulas are nearly identical to those in the previous post on the standard quadratic loss, except for the appearance of the <span class="math inline">\(\Sigma_{vv}^{-1}\)</span> terms.</p>
<p>As in the previous post, learning the gates with exponentiated gradient descent in the online context leads to a system of two coupled ordinary differential equations <span class="math display">\[
\begin{align}
\frac{d \, \omega_f}{d \, t} &amp;= \omega_f \left( s_J - \omega_i A_{J,l} - A_{J,J} \omega_f \right)
\\
\frac{d \, \omega_i}{d \, t} &amp;= \omega_i \left( s_l - \omega_f A_{J,l} - A_{l,l} \omega_i \right)
\end{align}
\]</span> describing a Lotka-Volterra model with two species. Assuming that the interaction matrix is invertible, the unconstrained solution is <span class="math display">\[
\begin{align}
\omega_f^* &amp;= \frac{A_{l,l} \, s_J - A_{J,l} \, s_l}{A_{J,J} \, A_{l,l} - A_{J,l}^2},
\\
\omega_i^* &amp;= \frac{A_{J,J} \, s_l - A_{J,l} \, s_J}{A_{J,J} \, A_{l,l} - A_{J,l}^2}\,.
\end{align}
\]</span> Taking into account the non-negativity constraints yields <span class="math display">\[
\begin{align}
\omega_f &amp;=
\begin{cases}
\omega_f^*, &amp; \text{if } \omega_i^* &gt; 0, \\[2mm]
\displaystyle \frac{s_J}{A_{J,J}}, &amp; \text{if } \omega_i^* \le 0,
\end{cases}\\[2mm]
\omega_i &amp;=
\begin{cases}
\omega_i^*, &amp; \text{if } \omega_f^* &gt; 0,\\[2mm]
\displaystyle \frac{s_l}{A_{l,l}}, &amp; \text{if } \omega_f^* \le 0,
\end{cases}
\end{align}
\]</span> which is a closed-form solution for optimal gated linear attention. Alternatively, one could simplify the system even further by treating <span class="math inline">\(\omega_f\)</span> as a user specified hyperparameter, in which case <span class="math display">\[
\omega_i = \max \Big\{0, \frac{s_l - \omega_f A_{J,l}}{A_{l,l}} \Big\} \,,
\]</span> is the corresponding optimal input gate. The resulting algorithm is shown below.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> greedy_invasion_update(J_prev, v, k, Sigma_vv, Sigma_qv, Sigma_qq):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Lotka-Volterra-inspired gated update </span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">    to memory matrix"""</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># invert value correlation matrix</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    inv_Sigma_vv <span class="op">=</span> torch.linalg.inv(Sigma_vv)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute ecological parameters</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    s_J <span class="op">=</span> torch.trace(inv_Sigma_vv <span class="op">@</span> J_prev <span class="op">@</span> Sigma_qv)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    s_l <span class="op">=</span> k <span class="op">@</span> Sigma_qv <span class="op">@</span> inv_Sigma_vv <span class="op">@</span> v</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    A_JJ <span class="op">=</span> torch.trace(inv_Sigma_vv <span class="op">@</span> J_prev <span class="op">@</span> Sigma_qq <span class="op">@</span> J_prev.T)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    A_ll <span class="op">=</span> (v <span class="op">@</span> inv_Sigma_vv <span class="op">@</span> v) <span class="op">*</span> (k <span class="op">@</span> Sigma_qq <span class="op">@</span> k)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    A_Jl <span class="op">=</span> v <span class="op">@</span> inv_Sigma_vv <span class="op">@</span> J_prev <span class="op">@</span> Sigma_qq <span class="op">@</span> k</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute unconstrained gates</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    denom <span class="op">=</span> A_JJ <span class="op">*</span> A_ll <span class="op">-</span> A_Jl<span class="op">**</span><span class="dv">2</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    omega_f <span class="op">=</span> (A_ll <span class="op">*</span> s_J <span class="op">-</span> A_Jl <span class="op">*</span> s_l) <span class="op">/</span> denom</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    omega_i <span class="op">=</span> (A_JJ <span class="op">*</span> s_l <span class="op">-</span> A_Jl <span class="op">*</span> s_J) <span class="op">/</span> denom</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply non-negativity constraints</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> omega_i <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        omega_f <span class="op">=</span> s_J <span class="op">/</span> A_JJ</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        omega_i <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> omega_f <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        omega_i <span class="op">=</span> s_l <span class="op">/</span> A_ll</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        omega_f <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Gated memory update</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    J_new <span class="op">=</span> omega_f <span class="op">*</span> J_prev <span class="op">+</span> omega_i <span class="op">*</span> torch.outer(v, k)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> J_new</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-beck2025xlstm" class="csl-entry" role="listitem">
Beck, Maximilian, Korbinian Pöppel, Markus Spanring, Andreas Auer, Oleksandra Prudnikova, Michael Kopp, Günter Klambauer, Johannes Brandstetter, and Sepp Hochreiter. 2025. <span>“Xlstm: Extended Long Short-Term Memory.”</span> <em>Advances in Neural Information Processing Systems</em> 37: 107547–603.
</div>
</div></section></div></main> <!-- /main -->
<hr style="margin: 2rem 0; border: 0; border-top: 2px solid #ccc;">

<h2>Subscribe to Updates</h2>

<p>Enter your email below if you want to subscribe to be automatically notified of new posts.</p>

<form action="https://assets.mailerlite.com/jsonp/1441877/forms/151220238201914872/subscribe" method="post" target="_blank" style="max-width: 500px; margin-bottom: 30px;">
  <div style="display: flex; margin-bottom: 10px;">
    <input type="email" name="fields[email]" placeholder="Your email address" required="" style="flex-grow: 1; padding: 8px; margin-right: 10px; border: 1px solid #ccc; border-radius: 4px;">
    <button type="submit" style="background-color: #1677be; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
      Subscribe
    </button>
  </div>
  <p style="font-size: 0.8em; color: #666;">
    We respect your privacy. Unsubscribe at any time.
  </p>
  <input type="hidden" name="ml-submit" value="1">
  <input type="hidden" name="anticsrf" value="true">
</form>

<script>
    document.addEventListener('DOMContentLoaded', function() {
      const form = document.querySelector('form[action*="mailerlite"]');
      if (form) {
        form.addEventListener('submit', function(e) {
          e.preventDefault();
          const email = form.querySelector('input[name="fields[email]"]').value;
          const formData = new FormData();
          formData.append('fields[email]', email);
          formData.append('ml-submit', '1');
          formData.append('anticsrf', 'true');
          
          fetch(form.action, {
            method: 'POST',
            body: formData,
            mode: 'no-cors'
          })
          .then(() => {
            // Show success message
            form.innerHTML = '<p style="color: #1677be; font-weight: bold;">Thank you! You\'ve successfully subscribed to Local Minimum updates. You will receive a welcome email shortly; please check your spam folder if you don\'t see it.</p>';
          });
        });
      }
    });
  </script>

<div class="license-footer" style="margin-top: 2rem; padding-top: 1rem; border-top: 1px solid #eee; font-size: 0.8em; color: #666;">
  © 2025 Charles Fisher. This work is licensed under a <a href="../../license.html">Creative Commons Attribution 4.0 International License</a>.
</div>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/drckf\.github\.io\/local-minimum\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="drckf/local-minimum" data-repo-id="R_kgDOOVGEfA" data-category="Announcements" data-category-id="DIC_kwDOOVGEfM4Co189" data-mapping="pathname" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" data-loading="lazy" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="light">
</div> <!-- /content -->




</body></html>