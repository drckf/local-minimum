<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Charles Fisher">
<meta name="dcterms.date" content="2025-04-07">

<title>Weighted Linear Attention is Lotka-Volterra Dynamics – Local Minimum</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Local Minimum</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../license.html"> 
<span class="menu-text">License</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/drckf"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Weighted Linear Attention is Lotka-Volterra Dynamics</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">research</div>
                <div class="quarto-category">machine-learning</div>
                <div class="quarto-category">ecology</div>
                <div class="quarto-category">attention</div>
                <div class="quarto-category">lotka-volterra</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Charles Fisher </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">April 7, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="tldr" class="level2">
<h2 class="anchored" data-anchor-id="tldr">TLDR</h2>
<p>Weighted linear attention modules are key-value associative memories with potential uses in neural sequence models used for tasks such as language modeling. Here, I show that weighted linear attention can be interpreted as an evolving ecological system in which tokens are species and their weights are species abundances. The weights evolve under Lotka-Volterra dynamics when optimized via exponentiated gradient descent to minimize the squared recall error. This framework provides explicit formulas linking the statistics of the data distribution to ecological parameters such as the carrying capacity and interaction coefficients of each token.</p>
</section>
<section id="theory" class="level2">
<h2 class="anchored" data-anchor-id="theory">Theory</h2>
<p>Although ecology and evolutionary biology have inspired a variety of computational algorithms particularly in the area of non-convex optimization <span class="citation" data-cites="storn1997differential binitha2012survey">(<a href="#ref-storn1997differential" role="doc-biblioref">Storn and Price 1997</a>; <a href="#ref-binitha2012survey" role="doc-biblioref">Binitha, Sathya, et al. 2012</a>)</span>, there is little exploration of the relationship between ecological systems and neural networks. In a classical paper on theoretical ecology, Robert MacArthur showed that the Lotka-Volterra equations of competitive ecosystems minimize a quadratic Lyapunov function <span class="citation" data-cites="arthur1969species macarthur1970species">(<a href="#ref-arthur1969species" role="doc-biblioref">Arthur 1969</a>; <a href="#ref-macarthur1970species" role="doc-biblioref">MacArthur 1970</a>)</span>, establishing an interesting connection between ecological systems and non-negative least squares regression problems. Initially, this insight was primarily used to better understand the behavior of ecological communities, but recent work has taken the other direction and shown that ecological models can be applied to machine learning problems like training support vector machines <span class="citation" data-cites="mehta2019constrained howell2020machine">(<a href="#ref-mehta2019constrained" role="doc-biblioref">Mehta et al. 2019</a>; <a href="#ref-howell2020machine" role="doc-biblioref">Howell et al. 2020</a>)</span>.</p>
<p>In this post, I show that there is an exact correspondence between associative memories in the form of weighted linear attention and ecological systems described by Lotka-Volterra dynamics <span class="citation" data-cites="wangersky1978lotka schuster1983replicator bomze1983lotka bomze1995lotka cui2024houches">(<a href="#ref-wangersky1978lotka" role="doc-biblioref">Wangersky 1978</a>; <a href="#ref-schuster1983replicator" role="doc-biblioref">Schuster and Sigmund 1983</a>; <a href="#ref-bomze1983lotka" role="doc-biblioref">Bomze 1983</a>, <a href="#ref-bomze1995lotka" role="doc-biblioref">1995</a>; <a href="#ref-cui2024houches" role="doc-biblioref">Cui, Marsland III, and Mehta 2024</a>)</span>. This mapping opens up new avenues for interpreting attention modules and other types of associative memories in terms of well-established concepts from theoretical ecology and may also inspire new ways to interpret ecological dynamics using concepts from machine learning. Specifically, each token in a sequence corresponds to a species in an ecosystem. The weight of the token in the memory corresponds to its species abundance. The arrival of a new token in a data stream is equivalent to the invasion of the ecosystem by a new species. Tokens engage in competitive or mutualistic interactions determined by the statistics of their key, value, and query embeddings. The schematic in <a href="#fig-fig1" class="quarto-xref">Figure&nbsp;1</a> illustrates the high-level concepts linking ecology and attention.</p>
<div id="fig-fig1" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-fig1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="The_Ecology_of_Attention_Figure_1.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-fig1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: <strong>Mapping linear attention to ecology.</strong> Schematic comparing (A) species interacting in an ecological community to (B) tokens interacting within a context window.
</figcaption>
</figure>
</div>
<p>Linearized attention modules are an important area of research in machine learning as a potential alternative to softmax attention heads in transformers including modules such as linear attention, DeltaNet, xLSTMs, and state-space models that scale linearly with sequence length . Here, I focus on a particular form of weighted linear attention module determined by an associative memory matrix, <span class="math display">\[
J = \sum_{l} w_{l} \, \vec{v}_{l} \, \vec{k}_{l}^T \,,
\]</span> where <span class="math inline">\(l\)</span> denotes the token position, <span class="math inline">\(\vec{v}_l = W_{V} \vec{x}_l \in \mathbb{R}^{d_v}\)</span> is a value vector, <span class="math inline">\(\vec{k}_l = W_{K} \vec{x}_l \in \mathbb{R}^{d_k}\)</span> is a key vector, <span class="math inline">\(\vec{x}_l \in \mathbb{R}^{n}\)</span> is a token embedding, and <span class="math inline">\(w_l \geq 0\)</span> is the weight of token <span class="math inline">\(l\)</span> in memory. Recall from the memory is simply matrix multiplication, <span class="math display">\[
\tilde{v}_l = J \, \vec{q}_l
\]</span> where <span class="math inline">\(\vec{q}_l = W_Q \vec{x}_l \in \mathbb{R}^{d_k}\)</span> is a query vector. The task is how to specify the weights of the patterns in the associative memory in order to minimize the error in the recalled value vector. I’ve provided some background on weighted linear attention modules in <a href="../../posts/weighted-linear-attention/index.html">a previous post</a>.</p>
<p>The mean squared recall error for a batch of tokens <span class="math inline">\(\{ \vec{x}_l \}_{l=1}^L\)</span> is (up to a factor of <span class="math inline">\(1/2\)</span>), <span id="eq-squared-loss"><span class="math display">\[
C(\vec{w}) = \frac{1}{2 L} \sum_{l=1}^L || \vec{v}_l - J \, \vec{q}_l ||^2 \, .
\qquad(1)\]</span></span> Thus, a sensible strategy is to choose the weights to minimize the squared error subject to the non-negativity constraint. This is closely related to a recently introduced framework called ``test-time regression’’ aiming to unify different methods for associative recall <span class="citation" data-cites="wang2025test kohonen1972correlation hinton2014parallel">(<a href="#ref-wang2025test" role="doc-biblioref">Wang, Shi, and Fox 2025</a>; <a href="#ref-kohonen1972correlation" role="doc-biblioref">Kohonen 1972</a>; <a href="#ref-hinton2014parallel" role="doc-biblioref">Hinton and Anderson 2014</a>)</span>. It turns out that the results that follow are largely applicable for a wide class of loss functions, which I’ll demonstrate in a future blog post. To learn the weights, the cost function can be minimized using a simple variant of exponentiated gradient descent to satisfy the non-negativity constraint <span class="citation" data-cites="kivinen1995additive">(<a href="#ref-kivinen1995additive" role="doc-biblioref">Kivinen and Warmuth 1995</a>)</span>. The update rule for exponentiated gradient descent with non-negative weights is <span class="math display">\[
w_l' = w_l e^{-\eta \frac{\partial C}{\partial w_l}} \, .
\]</span> In the continuous-time limit (i.e., very small <span class="math inline">\(\eta\)</span>), this update rule leads to the following differential equation <span class="math display">\[
\frac{d \, w_l}{d \, t} = - w_l \frac{\partial C}{\partial w_l}
\]</span> that describes the dynamics of the weights under the exponentiated gradient descent.</p>
<p>After a bit of algebra, it’s possible to compute the averages over the batch in order to derive the squared recall error <span class="math display">\[
C(\vec{w})
= \frac{1}{2} \text{Tr}\Big( \Sigma_{vv} \Big)
- \text{Tr}\Big(J \, \Sigma_{qv} \Big)
+ \frac{1}{2} \text{Tr}\Big(J \, \Sigma_{qq} \, J^T \Big)
\]</span> where <span class="math display">\[
\begin{align}
\Sigma_{vv} &amp;= \frac{1}{L} \sum_{l=1}^L \vec{v}_l \, \vec{v}_l^T \\
\Sigma_{qv} &amp;= \frac{1}{L} \sum_{l=1}^L \vec{q}_l \, \vec{v}_l^T \\
\Sigma_{qq} &amp;= \frac{1}{L} \sum_{l=1}^L \vec{q}_l \, \vec{q}_l^T
\end{align}
\]</span> are observed correlation matrices. The derivative of the cost function with respect to the weights is <span class="math display">\[
\frac{\partial C}{\partial w_l}
= - s_l + \sum_{l'} A_{l, l'} \, w_{l'} \,.
\]</span> where <span class="math display">\[
\begin{align}
s_l &amp;= \vec{k}_l^T \, \Sigma_{qv} \, \vec{v}_l \,,
\\
A_{l,l'} &amp;= \vec{v}_l^T \, \vec{v}_{l'} \, \vec{k}_{l'}^T \, \Sigma_{qq} \, \vec{k}_{l}
\, .
\end{align}
\]</span> In analogy with the ecological literature, I call <span class="math inline">\(s_l\)</span> the “intrinsic growth rate” of token <span class="math inline">\(l\)</span> and <span class="math inline">\(A_{l,l'}\)</span> the “interaction coefficient” between tokens <span class="math inline">\(l\)</span> and <span class="math inline">\(l'\)</span>. The following code illustrates how to compute these quantities:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_correlations(q, v):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    L <span class="op">=</span> q.shape[<span class="dv">0</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    Sigma_vv <span class="op">=</span> v.T <span class="op">@</span> v <span class="op">/</span> L</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    Sigma_qv <span class="op">=</span> q.T <span class="op">@</span> v <span class="op">/</span> L</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    Sigma_qq <span class="op">=</span> q.T <span class="op">@</span> q <span class="op">/</span> L</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Sigma_vv, Sigma_qv, Sigma_qq</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ecological_params(K, V, Sigma_qv, Sigma_qq):</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> (K <span class="op">@</span> Sigma_qv <span class="op">*</span> V).<span class="bu">sum</span>(dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> (V <span class="op">@</span> V.T) <span class="op">*</span> (K <span class="op">@</span> Sigma_qq <span class="op">@</span> K.T)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s, A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Plugging in these results yields the following differential equation describing the dynamics of the weights, <span id="eq-lotka-volterra"><span class="math display">\[
\frac{d \, w_l}{d \, t} =  w_l \Big( s_l - \sum_{l'} A_{l, l'} \, w_{l'} \Big) \,,
\qquad(2)\]</span></span> which is exactly the generalized Lotka-Volterra equation. A simple algorithm for integrating the Lotka-Volterra equations is shown in the following code snippet:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> integrate_lv(w, s, A, t_max, dt<span class="op">=</span><span class="fl">0.01</span>):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> t <span class="op">&lt;</span> t_max:</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        w <span class="op">=</span> w <span class="op">+</span> dt <span class="op">*</span> w <span class="op">*</span> (s <span class="op">-</span> A <span class="op">@</span> w)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        w <span class="op">=</span> w.clamp(<span class="bu">min</span><span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        t <span class="op">+=</span> dt</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> w</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Although relatively straightforward, as far as I know the derivation of <a href="#eq-lotka-volterra" class="quarto-xref">Equation&nbsp;2</a> as a way to minimize the squared recall error for weighted linear attention is a new result.</p>
<p>This construction allows one to directly interpret the terms in <a href="#eq-lotka-volterra" class="quarto-xref">Equation&nbsp;2</a> as ecologically inspired quantities. For example, a token is a species. The weight of a token is the abundance of the species. The intrinsic growth rate of species <span class="math inline">\(l\)</span> is <span class="math inline">\(s_l\)</span>, which defines how quickly the weight of the corresponding token increases at the start of learning. The total weight of a token is generally limited by its intrinsic growth rate <span class="math inline">\(s_l\)</span> and self-interaction <span class="math inline">\(A_{l,l'}\)</span> via a quantity known as its carrying capacity <span class="math display">\[
\kappa_l
= \frac{s_l}{A_{l,l}}
= \frac{\vec{k}_l^T \, \Sigma_{qv} \, \vec{v}_l}{\vec{v}_l^T \, \vec{v}_{l} \, \vec{k}_{l}^T \, \Sigma_{qq} \, \vec{k}_{l}} \,,
\]</span> which determines the weight of a token in the absence of interactions with the other tokens.</p>
<p>Of course, tokens do interact with each other. Two tokens compete if <span class="math inline">\(A_{l,l'} = A_{l', l} &gt; 0\)</span> and they cooperate if <span class="math inline">\(A_{l,l'} = A_{l', l} &lt; 0\)</span>. There are no predator-prey style interactions (i.e., <span class="math inline">\(A_{l,l'} = -A_{l', l}\)</span>) in this model because the interaction matrix is symmetric. Since the interaction matrix is symmetric, the species abundances will converge to a fixed point without any cycles. The interior fixed point is unique if <span class="math inline">\(A^{-1} \, \vec{s}\)</span> is strictly positive, otherwise there can be multiple fixed points on the boundary in which one, or multiple, species are extinct.</p>
<p><a href="#fig-interactions" class="quarto-xref">Figure&nbsp;2</a> shows how the interactions between tokens in the context window are determined by the alignment of their value vectors and the correlation of their attention scores.</p>
<div id="fig-interactions" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-interactions-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="The_Ecology_of_Attention_Schematics_Interaction_Diagram.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:95.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-interactions-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: <strong>Interpreting interactions</strong>. Interactions between tokens are related to the correlation of their attention scores and the alignment of their value vectors.
</figcaption>
</figure>
</div>
<p>To illustrate this, define the attention score <span class="math inline">\(\theta_{l,l'} = \vec{k}_l^T \, \vec{q}_{l'}\)</span> and the alignment score <span class="math inline">\(\phi_{l,l'} = \vec{v}_l^T \, \vec{v}_{l'}\)</span> between tokens <span class="math inline">\(l\)</span> and <span class="math inline">\(l'\)</span>. Although the alignment scores are symmetric, the attention scores are not; token <span class="math inline">\(l\)</span> may attend to token <span class="math inline">\(l'\)</span> differently from the way token <span class="math inline">\(l'\)</span> attends to token <span class="math inline">\(l\)</span>. By substituting the formula for the correlation matrix, one can derive an equation for the intrinsic growth rate of token <span class="math inline">\(l\)</span> as <span class="math display">\[
\begin{align}
s_l
&amp;= \frac{1}{L} \sum_{l'} \theta_{l,l'} \, \phi_{l,l'} \,,
\\
&amp;\sim \text{Covariance}\left(\text{attention}, \text{alignment}\right)
\,.
\end{align}
\]</span> Thus, the intrinsic growth rate of a token is the (uncentered) covariance between its attention scores and alignment scores. Token <span class="math inline">\(l\)</span> will have a high growth rate if its value is aligned with the values of the other tokens that attend to it. Similarly, the self-interaction is <span class="math display">\[
\begin{align}
A_{l,l}
&amp;= \phi_{l,l} \, \left( \frac{1}{L} \sum_{l'} \theta_{l,l'}^2 \right) \,,
\\
&amp;\sim \text{Norm}^2\left(\text{value}\right) \cdot \text{Variance}\left(\text{attention}\right)
\, .
\end{align}
\]</span> Thus, the self-interaction coefficient for a token <span class="math inline">\(l\)</span> is the squared norm of its value vector multiplied by the (uncentered) variance of its attention scores. Since the carrying capacity is the ratio of the growth rate to the self-interaction, it looks like the covariance between the attention and alignment scores divided by the variance of the attention scores and the norm of the value vector. The interaction between different tokens <span class="math inline">\(l\)</span> and <span class="math inline">\(l'\)</span> has a similar interpretation <span class="math display">\[
\begin{align}
A_{l,l'}
&amp;= \phi_{l,l'} \left( \frac{1}{L} \sum_{l''} \theta_{l,l''} \, \theta_{l', l''} \right)
\,, \\
&amp;\sim \text{Alignment} \cdot \text{Covariance}\left( \text{attention}, \text{attention} \right)
\,.
\end{align}
\]</span> Thus, two tokens are in competition if their values are aligned and they are attended to by similar tokens. Such tokens provide similar information, so there is no need to store both of them if the memory has limited capacity. Interestingly, tokens can also cooperate with each other. This happens if their values are aligned but they have anti-correlated attention scores, or if they have opposite values with positively correlated attention maps.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Attention mechanisms have become the cornerstone of modern sequence models. However, because the standard formulation of attention scales with the length of the context window squared, there has been a lot of recent interest in alternative approaches with linear scaling. Most of these alternative architectures involve weighted linear attention modules of some form. So far, these architectures based on key-value associative memories have generally fallen short of their transformer counterparts, raising an important question of `why?’.</p>
<p>Here, I have provided a new lens through which to view attention mechanisms–that of ecosystems. Specifically, I’ve shown that weighted associative memories based on query-key-value recall mechanisms correspond to ecological communities in which the tokens are species and the weights in the memory are their species abundances. In fact, this is more than a colorful metaphor, and the dynamics of exponentiated gradient descent on a squared reconstruction loss are exactly described by Lotka-Volterra dynamics.</p>
<p>This theory highlights some simple tools for understanding the inner workings of attention mechanisms. For example, the covariance between a token’s attention scores and its alignment scores determines its intrinsic growth rate. However, the intrinsic growth rate is, by itself, not enough to specify the weight of a token in the memory because tokens also interact with each other. In fact, the alignment of two tokens value vectors and the covariance of their attention scores determines if the tokens compete with each for space in the memory, or if they actually cooperate and reinforce each other’s weights.</p>
<p>In the following post, Weighted Linear Attention as Species Invasion, I will show that within a streaming context, online updating of an associative memory is equivalent to the invasion of an ecosystem by a new species. And, I’ll use this mapping to derive some novel ecologically inspired attention modules, including a closed-form solution for optimal gated linear attention.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-arthur1969species" class="csl-entry" role="listitem">
Arthur, Robert Mac. 1969. <span>“Species Packing, and What Competition Minimizes.”</span> <em>Proceedings of the National Academy of Sciences</em> 64 (4): 1369–71.
</div>
<div id="ref-binitha2012survey" class="csl-entry" role="listitem">
Binitha, S, S Siva Sathya, et al. 2012. <span>“A Survey of Bio Inspired Optimization Algorithms.”</span> <em>International Journal of Soft Computing and Engineering</em> 2 (2): 137–51.
</div>
<div id="ref-bomze1983lotka" class="csl-entry" role="listitem">
Bomze, Immanuel M. 1983. <span>“Lotka-Volterra Equation and Replicator Dynamics: A Two-Dimensional Classification.”</span> <em>Biological Cybernetics</em> 48 (3): 201–11.
</div>
<div id="ref-bomze1995lotka" class="csl-entry" role="listitem">
———. 1995. <span>“Lotka-Volterra Equation and Replicator Dynamics: New Issues in Classification.”</span> <em>Biological Cybernetics</em> 72 (5): 447–53.
</div>
<div id="ref-cui2024houches" class="csl-entry" role="listitem">
Cui, Wenping, Robert Marsland III, and Pankaj Mehta. 2024. <span>“Les Houches Lectures on Community Ecology: From Niche Theory to Statistical Mechanics.”</span> <em>ArXiv</em>, arXiv–2403.
</div>
<div id="ref-hinton2014parallel" class="csl-entry" role="listitem">
Hinton, Geoffrey E, and James A Anderson. 2014. <em>Parallel Models of Associative Memory: Updated Edition</em>. Psychology press.
</div>
<div id="ref-howell2020machine" class="csl-entry" role="listitem">
Howell, Owen, Cui Wenping, Robert Marsland, and Pankaj Mehta. 2020. <span>“Machine Learning as Ecology.”</span> <em>Journal of Physics A: Mathematical and Theoretical</em> 53 (33): 334001.
</div>
<div id="ref-kivinen1995additive" class="csl-entry" role="listitem">
Kivinen, Jyrki, and Manfred K Warmuth. 1995. <span>“Additive Versus Exponentiated Gradient Updates for Linear Prediction.”</span> In <em>Proceedings of the Twenty-Seventh Annual ACM Symposium on Theory of Computing</em>, 209–18.
</div>
<div id="ref-kohonen1972correlation" class="csl-entry" role="listitem">
Kohonen, Teuvo. 1972. <span>“Correlation Matrix Memories.”</span> <em>IEEE Transactions on Computers</em> 100 (4): 353–59.
</div>
<div id="ref-macarthur1970species" class="csl-entry" role="listitem">
MacArthur, Robert. 1970. <span>“Species Packing and Competitive Equilibrium for Many Species.”</span> <em>Theoretical Population Biology</em> 1 (1): 1–11.
</div>
<div id="ref-mehta2019constrained" class="csl-entry" role="listitem">
Mehta, Pankaj, Wenping Cui, Ching-Hao Wang, and Robert Marsland III. 2019. <span>“Constrained Optimization as Ecological Dynamics with Applications to Random Quadratic Programming in High Dimensions.”</span> <em>Physical Review E</em> 99 (5): 052111.
</div>
<div id="ref-schuster1983replicator" class="csl-entry" role="listitem">
Schuster, Peter, and Karl Sigmund. 1983. <span>“Replicator Dynamics.”</span> <em>Journal of Theoretical Biology</em> 100 (3): 533–38.
</div>
<div id="ref-storn1997differential" class="csl-entry" role="listitem">
Storn, Rainer, and Kenneth Price. 1997. <span>“Differential Evolution–a Simple and Efficient Heuristic for Global Optimization over Continuous Spaces.”</span> <em>Journal of Global Optimization</em> 11: 341–59.
</div>
<div id="ref-wang2025test" class="csl-entry" role="listitem">
Wang, Ke Alexander, Jiaxin Shi, and Emily B Fox. 2025. <span>“Test-Time Regression: A Unifying Framework for Designing Sequence Models with Associative Memory.”</span> <em>arXiv Preprint arXiv:2501.12352</em>.
</div>
<div id="ref-wangersky1978lotka" class="csl-entry" role="listitem">
Wangersky, Peter J. 1978. <span>“Lotka-Volterra Population Models.”</span> <em>Annual Review of Ecology and Systematics</em> 9: 189–218.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="drckf/local-minimum" data-repo-id="R_kgDOOVGEfA" data-category="Announcements" data-category-id="DIC_kwDOOVGEfM4Co189" data-mapping="pathname" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" data-loading="lazy" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="light">
</div> <!-- /content -->




</body></html>